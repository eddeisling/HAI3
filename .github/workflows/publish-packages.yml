name: Publish Packages

on:
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: read

jobs:
  detect-changes:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.detect.outputs.packages }}
      has_changes: ${{ steps.detect.outputs.has_changes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for squash-merge support

      - name: Detect version changes
        id: detect
        run: |
          PACKAGES=()

          # Use the PR's base commit SHA - works for ALL merge strategies
          # (standard merge, squash merge, AND rebase and merge)
          BASE_COMMIT="${{ github.event.pull_request.base.sha }}"
          echo "Comparing HEAD against PR base: $BASE_COMMIT"

          # Check each package for version changes
          for pkg_dir in packages/*/; do
            pkg_name=$(basename "$pkg_dir")
            pkg_json="$pkg_dir/package.json"

            if git diff "$BASE_COMMIT" --name-only | grep -q "$pkg_json"; then
              # Get old and new versions
              OLD_VERSION=$(git show "$BASE_COMMIT":"$pkg_json" 2>/dev/null | jq -r '.version' || echo "")
              NEW_VERSION=$(jq -r '.version' "$pkg_json")
              NPM_NAME=$(jq -r '.name' "$pkg_json")

              if [ "$OLD_VERSION" != "$NEW_VERSION" ] && [ -n "$NEW_VERSION" ]; then
                echo "Version change detected: $NPM_NAME $OLD_VERSION -> $NEW_VERSION"
                PACKAGES+=("{\"name\":\"$NPM_NAME\",\"dir\":\"$pkg_name\",\"version\":\"$NEW_VERSION\"}")
              fi
            fi
          done

          if [ ${#PACKAGES[@]} -eq 0 ]; then
            echo "No packages with version changes"
            echo "packages=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            # Use -c for compact single-line JSON (required for GITHUB_OUTPUT)
            JSON_ARRAY=$(printf '%s\n' "${PACKAGES[@]}" | jq -sc '.')
            echo "packages=$JSON_ARRAY" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

  publish:
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      published: ${{ steps.publish.outputs.published }}
      skipped: ${{ steps.publish.outputs.skipped }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '25.x'
          registry-url: 'https://registry.npmjs.org'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build all packages
        run: npm run build:packages

      - name: Publish packages in order
        id: publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          PACKAGES='${{ needs.detect-changes.outputs.packages }}'
          PUBLISHED_PACKAGES=()
          SKIPPED_PACKAGES=()

          # Retry function with exponential backoff
          publish_with_retry() {
            local max_attempts=3
            local attempt=1
            local delay=5

            while [ $attempt -le $max_attempts ]; do
              echo "Publish attempt $attempt of $max_attempts..."
              if npm publish --access public; then
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "Attempt $attempt failed. Retrying in ${delay}s..."
                sleep $delay
                delay=$((delay * 2))  # Exponential backoff: 5s, 10s, 20s
              fi
              attempt=$((attempt + 1))
            done

            echo "All $max_attempts attempts failed"
            return 1
          }

          # Sort packages by layer (L1=SDK, L2=Framework, L3=React, L4=Studio, L5=CLI)
          SORTED=$(echo "$PACKAGES" | jq -c 'sort_by(.dir |
            if . == "state" or . == "screensets" or . == "api" or . == "i18n" or . == "uikit" then 1
            elif . == "framework" then 2
            elif . == "react" then 3
            elif . == "studio" then 4
            else 5 end)')

          echo "Publishing order:"
          echo "$SORTED" | jq -r '.[] | "  - \(.name)@\(.version)"'

          # Publish each package
          for row in $(echo "$SORTED" | jq -r '.[] | @base64'); do
            _jq() {
              echo "${row}" | base64 --decode | jq -r "${1}"
            }

            NAME=$(_jq '.name')
            DIR=$(_jq '.dir')
            VERSION=$(_jq '.version')

            echo ""
            echo "=========================================="
            echo "Processing: $NAME@$VERSION"
            echo "=========================================="

            # Check if version already exists on NPM
            if npm view "$NAME@$VERSION" version 2>/dev/null; then
              echo "SKIPPING: $NAME@$VERSION already exists on NPM"
              SKIPPED_PACKAGES+=("{\"name\":\"$NAME\",\"version\":\"$VERSION\",\"reason\":\"already exists on NPM\"}")
              continue
            fi

            echo "Publishing $NAME@$VERSION..."
            cd "packages/$DIR"

            if ! publish_with_retry; then
              echo "FAILED: $NAME@$VERSION publish failed after retries"
              exit 1
            fi

            echo "SUCCESS: Published $NAME@$VERSION"
            PUBLISHED_PACKAGES+=("{\"name\":\"$NAME\",\"version\":\"$VERSION\"}")
            cd ../..
          done

          echo ""
          echo "=========================================="
          echo "All packages published successfully!"
          echo "=========================================="

          # Output results for summary job (use -c for compact single-line JSON)
          if [ ${#PUBLISHED_PACKAGES[@]} -eq 0 ]; then
            echo "published=[]" >> $GITHUB_OUTPUT
          else
            PUBLISHED_JSON=$(printf '%s\n' "${PUBLISHED_PACKAGES[@]}" | jq -sc '.')
            echo "published=$PUBLISHED_JSON" >> $GITHUB_OUTPUT
          fi

          if [ ${#SKIPPED_PACKAGES[@]} -eq 0 ]; then
            echo "skipped=[]" >> $GITHUB_OUTPUT
          else
            SKIPPED_JSON=$(printf '%s\n' "${SKIPPED_PACKAGES[@]}" | jq -sc '.')
            echo "skipped=$SKIPPED_JSON" >> $GITHUB_OUTPUT
          fi

  summary:
    needs: [detect-changes, publish]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Publish summary
        run: |
          echo "## Publish Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.detect-changes.outputs.has_changes }}" != "true" ]; then
            echo "No packages with version changes to publish." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.publish.result }}" == "success" ]; then
            # Published packages
            PUBLISHED='${{ needs.publish.outputs.published }}'
            PUBLISHED_COUNT=$(echo "$PUBLISHED" | jq 'length')
            if [ "$PUBLISHED_COUNT" -gt 0 ]; then
              echo "### ✅ Published ($PUBLISHED_COUNT)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "$PUBLISHED" | jq -r '.[] | "- `\(.name)@\(.version)`"' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            # Skipped packages
            SKIPPED='${{ needs.publish.outputs.skipped }}'
            SKIPPED_COUNT=$(echo "$SKIPPED" | jq 'length')
            if [ "$SKIPPED_COUNT" -gt 0 ]; then
              echo "### ⏭️ Skipped ($SKIPPED_COUNT)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "$SKIPPED" | jq -r '.[] | "- `\(.name)@\(.version)` - \(.reason)"' >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "❌ Publish failed. Check workflow logs for details." >> $GITHUB_STEP_SUMMARY
          fi
